\section{Computational Methods}\label{sec:computation-methods}

Given a BN \(\bn\), our approach is to construct an ASP program \(P\) such that the answer sets of \(P\) one-to-one correspond to the minimal trap spaces (or fixed points) of \(\bn\).
This reduction allows us to leverage existing answer set counters to efficiently count the answer sets of $P$.
For \acfirstmts{} and \acfirstfix{}, we simply use the ASP encodings of \tsconj and \fasp, respectively.
For \acsecondmts{} and \acsecondfix{}, we complement the encoding of the given phenotype.
For \acthirdmts{} and \acthirdfix{}, we propose a new perturbation encoding, which we consider to be a main contribution of this paper.
%In particular, our method builds upon the \tsconj~\cite{TBPS2024} and \fasp~\cite{TBS2023} encodings for minimal trap spaces and fixed points, respectively. 
Now, we begin by briefly reviewing the \tsconj and \fasp encodings.

\subsection{\tsconj and \fasp Encodings}

We first present the common components of the two encodings, followed by their differences.
The ASP encodings represent sub-spaces using atoms $\pos{v}$ and $\ngt{v}$, indicating whether variable $v$ is fixed to $1$, $0$, or left free. 
The goal is to translate BN trap space and fixed point properties into ASP rules whose answer sets correspond to these configurations.

Given a BN \(f\), the encodings compute an ASP program \(P\) as follows:
for each variable \(v \in \var{f}\), two atoms \(\pos{v}\) and \(\ngt{v}\) are introduced to indicate positive and negative assignments of the variable $v$, respectively.
Additionally, for every \(v \in \var{f}\), one rule of the form: \(\pos{v} \vee \ngt{v} \leftarrow \top\) is added to ensure that each answer set corresponds to a sub-space of $f$.
The translation from an answer set $M$ to a sub-space $m$ is defined as follows: for each \(v \in \var{f}\), we have (i) \(m(v) = 1\) if and only if \(\pos{v} \in M \land \ngt{v} \not \in M\), (ii) \(m(v) = 0\) if and only if \(\pos{v} \not \in M \land \ngt{v} \in M\), and (iii) \(m(v) = \star\) if and only if \(\pos{v} \in M \land \ngt{v} \in M\).
Recall that a trap space of \(f\) can be characterized by \(\bigwedge_{v \in \var{f}}(v \leftarrow f_v) \land (\neg v \leftarrow \neg f_v)\)~\cite{TBPS2024}.
For every \(v \in \var{f}\), two ASP rules --- (i) \(\gamma(v) \leftarrow \gamma(\nnf{f_v})\) and (ii) \(\gamma(\neg v) \leftarrow \gamma(\nnf{\neg f_v})\) --- are added to $P$ to express the characterization, where \(\nnf{\Phi}\) denotes a negation normal form of a Boolean formula \(\Phi\) and \(\gamma\) is a procedure defined as follows:
\begin{align*}
	\gamma(v) &= \pos{v}, \gamma(\neg v) = \ngt{v}, v \in \var{f}, \\
	\gamma(\bigwedge_{1\leq j\leq J}\alpha_{j}) &= \gamma(\alpha_{1}) \land \ldots \land \gamma(\alpha_{J}), \gamma(\bigvee_{1\leq j\leq J}\alpha_{j}) = \aux{k},
\end{align*}where \(\aux{k}\) is a new \emph{auxiliary} atom, \(k\) is a global counter starting from $1$ and shall be increased by $1$ after each new auxiliary atom is created, and for each \(j\), the rule \(\aux{k} \gets \gamma(\alpha_{j})\) is added to \(P\).

For the correctness of the \tsconj encoding, Trinh et al.~\cite{TBPS2024} defined a syntactic safeness condition for a Boolean formula $\Phi$: \(\Phi\) is considered safe if it does not contain any conjunction of two subformulas \(\Phi_1\) and \(\Phi_2\) such that there exists a variable \(x\) appearing in \(\Phi_1\) with \(\neg x\) appearing in \(\Phi_2\).
When both \(f_v\) and \(\neg f_v\) are safe for every \(v \in \var{f}\), then the set of answer sets of \(P\) one-to-one corresponds with the set of minimal trap spaces of \(f\).
When a Boolean formula \(\Phi\) (\(f_v\) or \(\neg f_v\)) is unsafe, the Disjunctive Normal Form (DNF) of $\Phi$ is used instead, which is always safe by definition.
%Note that unsafe formulas are quite rare due to their relatively simple update functions.

There is no notion of ``safeness'' in the \fasp encoding. 
Rather an additional rule \(\bot \leftarrow \pos{v}, \ngt{v}\) is added to $P$, for every \(v \in \var{f}\) such that the variable \(v\) cannot take the value of \(\star\).
The answer sets of \(P\) one-to-one correspond to the fixed points of \(f\).

Following on, given a BN $f$, we use the notations $\tsconjp{f}$ and $\faspp{f}$ to denote the encoded ASP programs of \(f\), according to the \tsconj and \fasp~encodings, respectively.

\subsection{Methods for Problems \acfirstmts{} and \acfirstfix{}}\label{subsec:methods-first}

% Note that the exact answer set counting~\cite{DBLP:conf/aaai/KabirCM24} is not applicable here because it is only applicable for NLPs, whereas all the ASP encodings use DLPs, as shown below.
% The proposed approach is quite natural, but it is a premise for solving more complex problems that we shall present in the two next sections.

% The pivotal point is to choose efficient ASP encodings.

We make use of \tsconj and \fasp encodings for~\acfirstmts{} and \acfirstfix{}, respectively. 
The choice of encodings is due to following two reasons:
first, these encodings rely on less expensive representations --- specifically, negation normal forms (ref.\ \Cref{sec:related-work}).
Second, they establish a one-to-one correspondence between the minimal trap spaces (or fixed points) of the original BN and the answer sets of the encoded ASP program, whereas other encodings yield a one-to-one correspondence with the subset-minimal (or subset-maximal) answer sets~\cite{ADFPR2023}, which prevents the direct use of existing ASP counters.

\subsection{Methods for Problems \acsecondmts{} and \acsecondfix{}}\label{subsec:methods-second}

We add the encoding of phenotype to the encodings of \tsconj and \fasp to solve counting problems \acsecondmts{} and \acsecondfix{}, respectively.
% We explain the case for \acsecondmts{}, and the technique can be extended for \acsecondfix{} similarly.
Given a BN \(\bn\) and a phenotype \(\phen\),
% let \(P\) be the encoded ASP program following the \tsconj encoding.
we compute an ASP program $\toaspalgname{\phen}$ to capture the phenotype \(\phen\) by invoking~\Cref{alg:to_asp}.
The algorithm exploits atoms introduced in the \tsconj encoding to interpret the phenotype $\phen$.
The main idea of~\Cref{alg:to_asp} is exploiting {\em faceted answer set navigation} to constrain the search space of answer sets~\cite{FGR2022}. 
We prove that the minimal trap spaces of \(\bn\) satisfying the phenotype \(\phen\) one-to-one correspond to the answer sets of \(\tsconjp{f} \cup \toaspalgname{\phen}\) (\cref{theo:encoding-correctness-mts}).
% Thereby, we can apply approximate answer set counting to estimating the number of answer sets of \(P \cup \phenasp\).
\begin{algorithm}[t]
	\caption{$\toaspalgname{\phen}$}
	\label{alg:to_asp}
	\hspace*{\algorithmicindent} \textbf{Input:} Phenotype $\phen$ \\
	\hspace*{\algorithmicindent} \textbf{Output:} ASP program $\phenasp$
	\algnotext{EndFor}
	\algnotext{EndIf}
	%\algnotext{EndWhile}
	\begin{algorithmic}[1]
		\State $\phenasp \gets \emptyset$
		\ForEach {$(v \leftrightarrow e) \in \phen$} 
		\If {$e = 1$}\label{line:condition_vee}
		%\State $\phenasp.\mathsf{add}(\bot \leftarrow \dng{\pos{v}}. \quad \bot \leftarrow \ngt{v}.)$ \label{line:true_value}
		\State $\phenasp.\mathsf{add}(\bot \leftarrow \dng{\pos{v}}, \qquad \bot \leftarrow \ngt{v})$ \label{line:true_value}
		\ElsIf {$e = 0$} 
		%\State $\phenasp.\mathsf{add}(\bot \leftarrow \pos{v}.  \quad \bot \leftarrow \dng{\ngt{v}}.)$ \label{line:false_value}
		\State $\phenasp.\mathsf{add}(\bot \leftarrow \pos{v}, \qquad \bot \leftarrow \dng{\ngt{v}})$ \label{line:false_value}
		\ElsIf {$e = \star$} 
		%\State $\phenasp.\mathsf{add}(\bot \leftarrow \dng{\pos{v}}.  \quad \bot \leftarrow \dng{\ngt{v}}.)$ \label{line:star_value}
		\State $\phenasp.\mathsf{add}(\bot \leftarrow \dng{\pos{v}}, \qquad \bot \leftarrow \dng{\ngt{v}})$ \label{line:star_value}
		\EndIf
		\EndFor
		% \State $\phenasp.\mathsf{add}(\leftarrow \negprop.)$
		\State \Return {$\phenasp$}
	\end{algorithmic}
\end{algorithm}
% Regarding the construction of \(\phenasp\), we mimic similar approaches of the \fasp and \tsconj.
% Given a property $\prop$, we can construct a representative ASP program $\phenasp$ to capture the interpretation of property $\prop$ as follows:
% first we replace every term \(v = b\) in \(\prop\) by \(\pos{v} \land \neg \ngt{v}\) if \(b = 1\), by \(\neg \pos{v} \land \ngt{v}\) if \(b = 0\), and by \(\pos{v} \land \ngt{v}\) if \(b = \star\).
% This aligns with the translation between answer sets and minimal trap spaces of the \tsconj encoding.
% Note that \(\prop\) is a propositional formula on \(V = \{\pos{v}, \ngt{v} \mid v \in \var{\bn}\}\).
% We then add to \(\phenasp\) the integrity constraint \(\leftarrow \negprop\) and the ASP rule \(\negprop \leftarrow \gamma'(\nnf{\neg \prop})\).

% Within the ASP program $\phenasp$, the atom \(\negprop\) interprets the negation of the property.
% The notation \(\gamma'\) is defined as
% \begin{align*}
% 	\gamma'(x) &= x, \gamma'(\neg x) = \dng{x}, x \in V, \\
% 	\gamma'(\bigwedge_{1\leq j\leq J}\alpha_{j}) &= \gamma'(\alpha_{1}) \land \ldots \land \gamma'(\alpha_{J}), \gamma'(\bigvee_{1\leq j\leq J}\alpha_{j}) = \temp{k},
% \end{align*}where \(\temp{k}\) is a new \emph{auxiliary} atom and for each \(j\) we add the rule \(\temp{k} \gets \gamma'(\alpha_{j})\) to \(\phenasp\).
% Similar to the \fasp and \tsconj encodings, \(k\) is a global counter starting from $1$ and will be increased by $1$ after a new auxiliary atom is introduced.

\begin{restatable}{theorem}{rcmtscorrectness}\label{theo:encoding-correctness-mts}
	Given a BN \(\bn\) and a phenotype \(\phen\),
	% let \(P\) be the encoded ASP program following the \tsconj encoding and \(\phenasp\) be the encoded ASP program expressing \(\phen\) (from~\Cref{alg:to_asp}).
	the minimal trap spaces of \(\bn\) satisfying \(\phen\) one-to-one correspond to the answer sets of \(\tsconjp{f} \cup \toaspalgname{\phen}\).
\end{restatable}

For \acsecondfix{}, we can apply the \fasp~encoding and~\Cref{alg:to_asp} similarly.
% let \(P\) be the encoded ASP program following the \fasp encoding.
% We apply the same notation $\gamma'$ over $\dng{\prop}$ to get $\phenasp$, which is the encoded ASP expressing $\prop$.
Note that in the counting problem \acsecondfix{}, the term \(e\) is either $0$ or $1$, for each \((v \leftrightarrow e) \in \phen\), since fixed points require all variables to be fixed.
% We prove that the fixed points of \(\bn\) satisfying \(\prop\) one-to-one correspond to the answer sets of \(P \cup \phenasp\) (Theorem~\ref{theo:encoding-correctness-fix}).
% Thereby, we can apply approximate answer set counting to estimating the number of answer sets of \(P \cup \phenasp\).
We formally prove the correctness of our proposed method for \acsecondfix{} in~\Cref{theo:encoding-correctness-fix}.

\begin{restatable}{theorem}{rcfixcorrectness}\label{theo:encoding-correctness-fix}
	Given a BN \(\bn\) and a phenotype \(\phen\),
	% let \(P\) be the encoded ASP program following the \fasp encoding and \(\phenasp\) be the encoded ASP program expressing \(\phen\) (from~\Cref{alg:to_asp}).
	the fixed points of \(\bn\) satisfying \(\phen\) one-to-one correspond to the answer sets of \(\faspp{f} \cup \toaspalgname{\phen}\).
\end{restatable}

\begin{example}
	Consider the BN \(f\) of~\Cref{exam:straight-BN}.
	The program $\tsconjp{f}$ is as follows:
	\begin{align*}
		&\pos{a} \vee \ngt{a} \leftarrow \top \quad \quad \pos{a} \leftarrow \pos{a}, \ngt{b} \quad \quad \ngt{a} \leftarrow \aux{1} \quad \quad \aux{1} \leftarrow \ngt{a} \quad \quad \aux{1} \leftarrow \pos{b} \\
		&\pos{b} \vee \ngt{b} \leftarrow \top \quad \quad \pos{b} \leftarrow \pos{a} \quad \quad \ngt{b} \leftarrow \ngt{a}
	\end{align*}
	The program $\tsconjp{f}$ has a unique answer set \(\{\ngt{a}, \ngt{b}, \aux{k}\}\) corresponding to the unique minimal trap space $00$ of \(f\).
	Consider the phenotype \(\phen = (b \leftrightarrow \star)\),
	the BN \(f\) has no minimal trap space satisfying \(\phen\) (see~\Cref{exam:four-first-problems}), thus \(\acsecondmts{}\) returns $0$.
	Following the procedure outlined above, the ASP program \(\toaspalgname{\phen}\) is as follows:
	\begin{align*}
		%&\bot \leftarrow \dng{\pos{b}}. \quad \quad \bot \leftarrow \dng{\ngt{b}}.
		&\bot \leftarrow \dng{\pos{b}} \qquad \bot \leftarrow \dng{\ngt{b}}
	\end{align*}
	Indeed, the program \(\tsconjp{f} \cup \toaspalgname{\phen}\) has no answer set.
\end{example}

\subsection{Methods for Problems \acthirdmts{} and \acthirdfix{}}\label{subsec:methods-third}

% Problems \acthirdfix{} and \acthirdmts{} are defined from a biological perspective and seem to be more difficult than the first four problems.
Given a BN \(\bn\), a phenotype \(\phen\), and a set of perturbable variables \(\pert\),
one possible approach to solving these problems is to introduce new atoms to represent possible perturbations over perturbable variables, then correspondingly to intervene in the encoded ASP program obtained by applying the encodings proposed for \acsecondmts{} and \acsecondfix{}, and finally to apply projected counting restricted to these new atoms.
Instead, we propose a more convenient approach that reduces \acthirdmts{} (resp.\ \acthirdfix{}) to \acsecondmts{} (resp.\ \acsecondfix{}) along with projected answer set counting.

\begin{definition}\label{def:BN-perturbation-trans}
	Consider a BN \(f\) and a set of perturbable variables \(\pert \subseteq \var{f}\),
	we construct a new BN \(g\) such that for every \(v \in \var{f}\), if \(v \in \var{f} \setminus \pert\), then the variable \(v \in \var{g}\) and \(g_v = f_v\), and if \(v \in \pert\), then three variables \(v, v^k, v^o \in \var{g}\) and 
	\begin{align*}
		g_v &= \neg v^k \land (v^o \lor f_v), \\
		g_{v^k} &= v^k, \\
		g_{v^o} &= v^o \land \neg v^k.
	\end{align*}
\end{definition}

% Instead of modifying the ASP encoding to model perturbations, we construct a perturbed version of the original BN, preserving the semantics of the original encoding.
% For each perturbable variable \(v \in \pert\), two new variables namely \(v^k\) and \(v^o\) are introduced to \(g\).
% By construction of the BN \(g\), if \(v^k\) receives value $1$, then \(v^o\) eventually receives value $0$ and \(v\) eventually receives value $0$, expressing the knockout perturbation of \(v\) in \(\bn\) because of the minimality of minimal trap spaces and fixed points.
% Similarly, if \(v^k\) and \(v^o\) receive values $0$ and $1$ respectively, then \(v\) eventually receives value $1$, expressing the over-expression perturbation of \(v\) in \(\bn\); if \(v^k\) and \(v^o\) receive value $0$, then the value of \(v\) updates by \(f_v\), expressing the case that \(v\) is unperturbed.
% The case that \(v^k\) and \(v^o\) receive value \(1\) is impossible because \(g_{v^o} = v^o \land \neg v^k\).
% Note that, since \(\var{\bn} \subseteq \var{g}\), the phenotype \(\phen\) is still well-defined in \(g\). 
% The set of minimal trap spaces (resp.\ fixed points) of \(g\) represents the set of minimal trap spaces (resp.\ fixed points) of \(f\) under all possible perturbations on \(\pert\).
% It follows that the set of minimal trap spaces (resp.\ fixed points) of \(g\) satisfying the phenotype \(\phen\) represents the set of minimal trap spaces (resp.\ fixed points) of \(f\) satisfying phenotype \(\phen\), under all possible perturbations on \(\pert\).
% For each perturbation, multiple satisfying minimal trap spaces (resp.\ fixed points) are counted once; as a result, we can get the number of satisfying perturbations.
% The counting problem \acthirdmts{} (resp.\ \acthirdfix{}) is equivalent to the projected version of \acsecondmts{} (resp.\ \acsecondfix{}) over the newly defined BN $g$. 
Instead of modifying the ASP encoding to model perturbations, we construct a perturbed version of the original BN, thereby preserving the semantics of the original encodings.
For each perturbable variable $v \in \pert$, we introduce two new variables in $g$: $v^k$, encoding whether $v$ is knocked out, and $v^o$, encoding whether it is over-expressed. By construction:
\begin{itemize}
	\item If $v^k = 1$, then $v^o = 0$ and $v = 0$, modeling a knockout of $v$.
	\item If $v^k = 0$ and $v^o = 1$, then $v = 1$, modeling over-expression.
	\item If $v^k = 0$ and $v^o = 0$, then $v$ follows its original update function $f_v$ ($v$ is unperturbed).
	\item The case $v^k = 1$ and $v^o = 1$ is infeasible due to the constraint $g_{v^o} = v^o \land \neg v^k$.
\end{itemize}
Since $\var{\bn} \subseteq \var{g}$, any phenotype $\phen$ defined over $\bn$ remains valid in $g$.
The minimal trap spaces (resp. fixed points) of $g$ correspond to those of $f$ under all possible perturbations over $\pert$.
Thus, the minimal trap spaces (resp. fixed points) of $g$ that satisfy the phenotype $\phen$ represent the perturbed solutions of $f$ that also satisfy $\phen$.
Crucially, for each perturbation, multiple satisfying minimal trap spaces (or fixed points) are counted once, enabling us to count the number of satisfying perturbations.
Hence, the counting problem \acthirdmts{} (resp. \acthirdfix{}) reduces to the projected version of \acsecondmts{} (resp. \acsecondfix{}) over the newly defined BN $g$.

We now discuss how we solve \acthirdmts{} and \acthirdfix{} by applying projected answer set counting.
We focus on the case for minimal trap spaces, and the case of fixed points is trivially similar.
% Let \(P\) be the encoded ASP program of \(g\) following the \tsconj encoding and \(\phenasp\) be the encoded ASP program interpreting the phenotype \(\phen\) (following~\Cref{alg:to_asp}).
Following~\Cref{theo:encoding-correctness-mts}, the set of answer sets of \(\tsconjp{g} \cup \toaspalgname{\phen}\) represents the set of minimal trap spaces of \(g\) satisfying the phenotype \(\phen\).
Let \(\aproj = \bigcup_{v \in \proj}\{\pos{v}, \ngt{v}\}\) denote the set of perturbation-related variables, where $\proj = \bigcup_{v \in \pert}\{v^k, v^o\}$ be the set of ASP atoms used in the encoding.
It follows that the number of answer sets of \(\tsconjp{g} \cup \toaspalgname{\phen}\), projected onto the set \(\aproj\) is equal to  the number of perturbation settings (i.e., assignments to variables in $\pert$) under which $g$ admits a minimal trap space satisfying $\phen$.

% \begin{definition}[Problem \acsecondfixp{}]\label{def:problem-second-FIX-projected}
% 	Given a BN \(\bn\), a property \(\prop\) of \(\bn\), and a set of projected variables \(\proj \subseteq \var{\bn}\), return the number of fixed points of \(\bn\) that satisfy \(\prop\) where multiple fixed points with the same values on the variables in \(\proj\) are only counted once.
% \end{definition}

% \begin{definition}[Problem \acsecondmtsp{}]\label{def:problem-second-MTS-projected}
% 	Given a BN \(\bn\), a property \(\prop\) of \(\bn\), and a set of projected variables \(\proj \subseteq \var{\bn}\), return the number of minimal trap spaces of \(\bn\) that satisfy \(\prop\) where multiple minimal trap spaces with the same values on the variables in \(\proj\) are only counted once.
% \end{definition}

\begin{restatable}{theorem}{correctnessperturbationreductionMTS}\label{theo:correctness-perturbation-reduction-MTS}
	Given a BN \(f\), a set of perturbable variables \(\pert \subseteq \var{f}\), a phenotype \(\phen\),
	% let \(P\) be the ASP program of the \tsconj~encoding over the BN \(g\) (\Cref{def:BN-perturbation-trans}), $\phenasp$ be the ASP program interpreting phenotype $\phen$ (following~\Cref{alg:to_asp}),  
	and \(\aproj = \bigcup_{v \in \proj}\{\pos{v}, \ngt{v}\}\), where $\proj = \bigcup_{v \in \pert}\{v^k, v^o\}$,
	then \acthirdmts{} can be computed as \(\projaspcount{\tsconjp{g} \cup \toaspalgname{\phen}, \aproj}\), where $g$ is the new BN according to~\Cref{def:BN-perturbation-trans}.
\end{restatable}
\begin{restatable}{theorem}{correctnessperturbationreductionFIX}\label{theo:correctness-perturbation-reduction-FIX}
	Given a BN \(f\), a set of perturbable variables \(\pert \subseteq \var{f}\), a phenotype \(\phen\),
	% let \(P\) be the ASP program of the \fasp~encoding over BN \(g\) (\Cref{def:BN-perturbation-trans}), $\phenasp$ be the ASP program interpreting phenotype $\phen$ (following~\Cref{alg:to_asp}),
	and \(\aproj = \bigcup_{v \in \proj}\{\pos{v}, \ngt{v}\}\), where $\proj = \bigcup_{v \in \pert}\{v^k, v^o\}$,
	then \acthirdfix{} can be computed as \(\projaspcount{\faspp{g} \cup \toaspalgname{\phen}, \aproj}\), where $g$ is the new BN following~\Cref{def:BN-perturbation-trans}.
\end{restatable}

\begin{example}\label{exam:third-MTS-projected}
	Consider again~\Cref{exam:third-MTS}.
	Following~\Cref{def:BN-perturbation-trans}, we obtain the BN \(g\): \(\var{g} = \{a, b, b^k, b^o\}\), \(g_a = a \land \neg b\), \(g_{b^k} = b^k\), \(g_{b^o} = b^o \land \neg b^k\), and \(g_{b} = \neg b^k \land (b^o \lor a)\).
	% By Theorem~\ref{theo:correctness-perturbation-reduction-MTS}, we have \(\acthirdmts{}(f, \{b\}, a = 0 \land b = 0) = \acsecondmtsp{}(g, a = 0 \land b = 0, \{b^k, b^o\})\).
	% Let \(P\) be the encoded ASP program of BN \(g\) following the \tsconj encoding and \(\phenasp\) be the encoded ASP program expressing the phenotype \(\phen\)
	(see Appendix~\ref{sec:detailed-ASP-programs} for the details of \(\tsconjp{g}\) and \(\toaspalgname{\phen}\)).
	Let \(\aproj = \{\pos{b^k}, \ngt{b^k}, \pos{b^o}, \ngt{b^o}\}\).
	Then \acthirdmts{} can be computed as $\projaspcount{\tsconjp{g} \cup \toaspalgname{\phen}, \aproj}$.
	% We have \(\acsecondmtsp{}(g, a = 0 \land b = 0, \{b^k, b^o\}) = \text{\#PASP}(P \cup \phenasp, \aproj)\).
	Indeed, $\projaspcount{\allowbreak \tsconjp{g} \cup \toaspalgname{\phen}, \aproj}$ returns $2$, which is consistent with the result shown in~\Cref{exam:third-MTS}.
\end{example}